#include <set>
#include <iostream>

#include <boost/python.hpp>
#include <boost/bind.hpp>
#include <boost/mpl/vector.hpp>

#include <QMetaObject>
#include <QMetaMethod>
#include <QVariant>
#include <QString>

//#include <icetray/I3Logging.h>

//#include "gil.h"
#include "pyqbind.h"
#include "pyqbind_detail.h"

namespace bp = boost::python;
using pyqbind_detail::ScopedGIL;

/**
 * Keeper of runtime pyqbind information
 */
static struct pyqbind_info{
	int initstate_;
	bp::object pyqbind_mod_;
	typedef std::map<QObject*, bp::object> instance_map;
	typedef std::map<const QMetaObject*, bp::object> metaclass_map;
	metaclass_map metaclasses_;
	instance_map instances_;
	pyqbind_info() : initstate_(0) {}
} pyqbind_info;

struct QString_to_python_str{
	static PyObject* convert( QString const& s ){
		return bp::incref( bp::object( s.toStdString() ).ptr() );
	}
};

struct python_str_to_QString{

	python_str_to_QString(){
		bp::converter::registry::push_back( &convertible, &construct, bp::type_id<QString>() );
	}

	static void* convertible( PyObject* obj_ptr ){
		if (!bp::extract<std::string>(obj_ptr).check()) return NULL;
		
		return obj_ptr;
	}

	static void construct( PyObject* obj_ptr, bp::converter::rvalue_from_python_stage1_data* data )
	{
		std::string value = bp::extract<std::string>(obj_ptr);
		void* storage = ((bp::converter::rvalue_from_python_storage<QString>*)data)->storage.bytes;
		new (storage) QString(value.c_str());
		data->convertible = storage;
	}
};


BOOST_PYTHON_MODULE( pyqbind )
{
	// disable autogenerated portion of function docstrings, as they are not useful
	bp::docstring_options docopt( false, false, false );
	bp::to_python_converter< QString, QString_to_python_str >();
	python_str_to_QString();
}

void PyQBind::pre_init()
{
#if PY_MAJOR_VERSION >= 3
	PyImport_AppendInittab("pyqbind", &PyInit_pyqbind);
#else
	PyImport_AppendInittab("pyqbind", &initpyqbind);
#endif
	pyqbind_info.initstate_ = 1;
}

void PyQBind::post_init()
{
	ScopedGIL gil;
	pyqbind_detail::register_metatypes();
	try {
		pyqbind_info.pyqbind_mod_ = bp::import("pyqbind");
		pyqbind_info.pyqbind_mod_.attr("_all_objects") = bp::list();
	} catch( bp::error_already_set e ){
		PyErr_Print();
		throw;
	}
	log_debug_stream( "pyqbind has initialized" );
	pyqbind_info.initstate_ = 2;
}

/** Extract the metamethod name */
static std::string make_method_name( QMetaMethod method )
{
	std::string sig = method.signature();
	return sig.substr(0, sig.find('('));
}

static std::set< std::string > split( std::string list, std::string separators=", " ){
	std::set< std::string> ret;
	size_t sep;
	while( (sep = list.find_first_of(separators)) != list.npos ){
		ret.insert( list.substr(0,sep) );
		list = list.substr(sep+1);
	}
	ret.insert(list);
	return ret;
}

static std::set< std::string > get_scriptable_props( const QMetaObject* meta ){
	std::set< std::string > props;
	int idx = meta->indexOfClassInfo( "pyqbind_scriptable_props" );
	if( idx != -1 ){
		std::string list( meta->classInfo( idx ).value() );
		std::cerr << "Scriptable properties for " << meta->className() << ":" << list << std::endl;
		props = split(list);
	}
	else{
		for( int i = 0; i< meta->propertyCount(); ++i ){
			QMetaProperty prop = meta->property(i);
			props.insert( prop.name() );
		}
	}
	return props;
}

static std::set< std::string > get_scriptable_slots( const QMetaObject* meta ){
	std::set< std::string > props;
	int idx = meta->indexOfClassInfo( "pyqbind_scriptable_slots" );
	if( idx != -1 ){
		std::string list( meta->classInfo( idx ).value() );
		std::cerr << "Scriptable properties for " << meta->className() << ":" << list << std::endl;
		props = split(list);
	}
	else{
		for( int i = 0; i< meta->methodCount(); ++i ){
			QMetaMethod method = meta->method(i);
			props.insert( make_method_name(method) );
		}
	}
	return props;
}

bp::object get_classdef( const QMetaObject* meta )
{
	pyqbind_info::metaclass_map::const_iterator iter;
	if( (iter=pyqbind_info.metaclasses_.find( meta )) != pyqbind_info.metaclasses_.end()){
		/* This class has been previously exported */
		return (*iter).second;
	}

	log_debug_stream( "Exporting metaobject " << meta->className() );
	const char* classname = meta->className();
	//bp::class_<QObject, boost::shared_ptr<QObject>, boost::noncopyable> classdef(classname);
	bp::class_<QObject, boost::noncopyable> classdef(classname, bp::no_init);
	classdef.attr("__module__") = "pyqbind";

	std::set< std::string > scriptable = get_scriptable_props( meta );
	/* Export properties */
	for( int i = 0; i < meta->propertyCount(); ++i ){
		QMetaProperty prop = meta->property(i);
		std::string name = prop.name();
		if( scriptable.count(name) == 0 )
			name = "_" + name;
		try{
			if( prop.isWritable() ){
				classdef.add_property( name.c_str(), pyqbind_detail::make_metaproperty_reader(prop),
				                                     pyqbind_detail::make_metaproperty_writer(prop) );
			}
			else{
				classdef.add_property( name.c_str(), pyqbind_detail::make_metaproperty_reader( prop ) );
			}
		}
		catch( PyQBind::error& e ){
			log_warn_stream( "Could not export property " << prop.name() );
		}
	}

	/* Export slots */
	scriptable = get_scriptable_slots( meta );
	for( int i = 0; i < meta->methodCount(); ++i ){
		QMetaMethod method = meta->method(i);
		if( method.methodType() != QMetaMethod::Slot ) continue;
		if( method.access() != QMetaMethod::Public ) continue;
		std::string name = make_method_name(method);
		if( name == "deleteLater" ) continue;  /* because calling this from python is a bad idea */
		if( scriptable.count(name) == 0 )
			name = "_" + name;
		classdef.def( name.c_str(), pyqbind_detail::make_invoker(method) );
	}

	pyqbind_info.metaclasses_[ meta ] = classdef;
	return classdef;
}

void PyQBind::exportObject( QObject* q ){
	ScopedGIL gil;
	const QMetaObject* meta = q->metaObject();
	try{
		bp::object classdef = get_classdef( meta );
		bp::object mod = pyqbind_info.pyqbind_mod_;
		bp::object exported( bp::ptr(q) );
		exported.attr("__class__") = classdef;
		pyqbind_info.instances_[ q ] = exported;
		mod.attr("_all_objects").attr("append")(exported);
	}
	catch( bp::error_already_set e ){
		PyErr_Print();
	}
}

void PyQBind::addToGlobalNamespace( QObject* q, const std::string& name ){
	ScopedGIL gil;
	log_debug_stream( "To global namespace: " << name );
	pyqbind_info::instance_map::iterator i = pyqbind_info.instances_.find(q);
	if( i != pyqbind_info.instances_.end() ){
		bp::import("__main__").attr(name.c_str()) = (*i).second;
	}
	else
		throw PyQBind::error("Object is not part of pyqbind");
}


void PyQBind::addToParent( QObject* parent, QObject* child, const std::string& attrname ){
	ScopedGIL gil;
	log_debug_stream( "To parent namespace: " << attrname );
	pyqbind_info::instance_map::iterator p = pyqbind_info.instances_.find(parent);
	pyqbind_info::instance_map::iterator c = pyqbind_info.instances_.find(child);
	if( p == pyqbind_info.instances_.end() ){
		throw PyQBind::error("Parent is not part of pyqbind");
	}
	if( c == pyqbind_info.instances_.end() ){
		throw PyQBind::error("Child is not part of pyqbind");
	}
	bp::object p_obj = (*p).second;
	bp::object c_obj = (*c).second;
	try{
#if PY_MAJOR_VERSION >= 3
		if( bp::import("builtins").attr("hasattr")(p_obj, attrname.c_str())){
#else
		if( bp::import("__builtin__").attr("hasattr")(p_obj, attrname.c_str())){
#endif
			log_warn_stream( "Overriding existing attribute in parent object: " << attrname );
		}
		p_obj.attr(attrname.c_str()) = c_obj;
	}
	catch( bp::error_already_set& e ){
		PyErr_Print();
	}
}
